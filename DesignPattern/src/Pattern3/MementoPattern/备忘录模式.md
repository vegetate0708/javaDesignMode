# 备忘录模式
* **概述**:在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样可以将对象恢复到原先保存的状态.
* **帮助理解**:备忘录模式就是为对象提供一个备份的地方,当对象想要回滚到前一个状态时,调用备忘录对象直接就可以恢复.
* **使用场景** 
  * 需要保存一个对象在某一个时刻的状态或者部分状态
  * 一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态
* **备忘录模式包含的角色**
  * **Originator** : 原发器,也就是发起者.记录有当前时刻自身的内部状态,负责创建一个备忘录Memento,用于记录当前时刻自身的内部状态,并可使用备忘录恢复内部状态.Originator可以根据需要决定Memento存储自己的哪些内部状态(发起者可能有很多内部状态,可以决定哪些由备忘录备份)
  * **Memento** : 备忘录.负责存储Originator对象的内部状态,并可以防止Originator之外的其它对象访问备忘录.备忘录有两个接口.Caretaker只能看到备忘录的窄接口,他只能将备忘录对象传递给其它对象.Originator却能够看到备忘录的宽接口.允许它访问返回到先前状态所需要的所有数据.
  * **Caretaker** : 管理者.负责保存备忘录.但是不能对备忘录的内容进行操作和访问.只能够将备忘录传递给其它对象.
* **优点**
  * 有时一些发起人对象的内部信息必须保存在发起人对象以外的地方,但是必须由发起人对象自己读取.这时使用备忘录模式可以将复杂的发起人内部信息对其它对象屏蔽起来.从而可以恰当的保持封装的边界.
  * 备忘录模式简化了发起者类.发起者不再需要管理和保存其内部状态的一个个版本.客户端可以自行管理他们所需要的这些状态的版本.
  * 当发起者角色的状态发生改变的时候.有可能这个状态无效,需要回滚到前一个状态.这时候可以使用暂时存储起来的备忘录将状态进行还原.
* **缺点**
  * 如果发起者角色的状态有很多并且需要完整的储存到备忘录对象中.那么备忘录对象会很消耗资源.
* **注意事项**
备忘录模式最理想的情况是只允许生成该备忘录的那个原发器能够访问这个备忘录的内部状态.