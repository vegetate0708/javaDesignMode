# 解释器模式
* **概述 **: 给定一个语言,定义它的文法表示,并定义一个解释器,这个解释器使用该标识来解释语言中的句子.
* **使用场景** :?如果一种特定类型的问题发生的频率足够高,那么可能就值得将该问题的各个实例表述为一个简单语言中的句子.这样就可以构建一个解释器,该解释器通过解释这些句子来解决该问题.
* **解释器模式的结构 **:
  * 抽象解释器 : 声明一个所有具体表达式都要实现的抽象接口(或者抽象类),接口中主要是一个interpret()方法,成为解释操作.具体解释任务由它的各个实现类来完成,
  * 终结符表达式 : 实现与文法中的元素相关联的解释操作,通常一个解释器模式中只有一个终结符表达式,但有多个实例,对应不同的终结符.终结符一半是文法中的运算单元.比如有一个简单的公式R=R1+R2,在里面R1和R2就是终结符,对应的解析R1和R2的解释器就是终结符表达式.
  * 非终结符表达式 : 文法中的每条规则对应于一个非终结符表达式,非终结符表达式一般是文法中的运算符或者其他关键字,比如公式R=R1+R2中,”+"就是非终结符,解析”+”的解释器就是一个非终结符表达式.非终结符表达式根据逻辑的复杂程度而增加,原则上每个问法规则都对应一个非终结符表达式.
  * 环境角色 : 这个角色的任务一般是用来存放文法中各个终结符所对应的具体值,比如R=R1+R2,我们给R1赋值1,给R2赋值2,这些信息需要存放到环境角色.
* **优点:**
  * 可扩展性比较好,灵活
  * 增加了新的解释表达式的方式
  * 易于实现简单文法
* **缺点:**
  * 可利用场景比较小
  * 对于复杂的文法比较难维护
  * 解释器模式会引起类膨胀