1：以点咖啡为例：
    我们在点咖啡的时候通常会有这样的情况：
      点了不同的咖啡会有不同的价格，此时我们需要一个咖啡的基类，不同的咖啡重写基类的cost()方法来实现自己的价格，但有时候我们点咖啡的时候会需要添加一些额外的调料，这个时候价格就变了，而这些额外的调料现在又是不确定的，如果提供过多的set()和get()方法来进行调料的添加又会出现新的问题，如果后续推出茶，汽水之类的饮料时，我们从基类那里继承过来很多没用的set和get方法
     所以在这里我们采用不一样的做法：以饮料为主体，然后在运行时以调料来“装饰”饮料，比如说顾客想要 加摩卡和加奶泡的深培咖啡，那么，要做的是：

    1:拿一个深培咖啡对象（DarkRoast）

    2:以摩卡(Mocha)对象装饰它

    3:以奶泡(Whip)对象装饰它

    4：调用cost()方法，并依赖委托(delegate)将调料的价钱加上去

    最后在运行的时候：首先，调用最外圈装饰着Whip的cost()方法，Whip调用Mocha的cost()方法，Mocha调用DarkRoast的cost()方法，DarkRoast返回它的价钱$0.99，Mocha在DarkRoast的结果上加上自己的价钱$0.20,返回新的价钱$1.19。Whip在Mocha的返回结果上加上自己的价钱$0.10,然后返回最后结果$1.29。

 装饰者模式具有以下特点：

     装饰者和被装饰者对象具有相同的超类型。

      你可以用一个或多个装饰者包装一个对象。

      既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始的对象（被包装的）的场合，可以用装饰过的对象替代它。

      装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。

      对象可以在任何时候被装饰，所以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。

装饰者模式的说明：

     装饰者模式动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
     
2：javaIO中的装饰者模式：
   InputStream是我们的抽象组件  
      FileInputStream   
      StringBufferInputStream 
      ByteArrayInputStream 
      FilterInputStream(抽象装饰者) 
                         具体装饰者：
          BufferedInputStream
          DataInputStream
          LineNumberInputStream
          PushbackInputStream
       我们可以自己创建自己的程序来测试I/O装饰者模式
       LowerCaseInputStream,可以把输入的所有大写字母变为小写字母       
       
          
       
     
     